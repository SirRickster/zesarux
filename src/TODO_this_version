

-Opción por defecto no permitir "zoom x" diferente de "zoom y" al redimensionar ventana mediante ratón. Quedarse con valor inferior de zoom
ok *pendiente sdl1,sdl2,X11. acabar de probar bien

-SDL2 no deja cambiar a zoom 2 redimensionando con ratón

-sdl en debian 12 32 bits inicializa muy lento


---------------------

--Inicio lectura mando analógico, como un volante


Probar en diferentes sistemas:
*acabar de probarlo de nuevo en todos: SDL windows, SDL linux, linux nativo, mac.

*continental circus, ---steering-wheel-address b50ch, parece de 16 bits, pero no va bien. intentar que funcione


--Fin lectura mando analógico, como un volante

---------------------


ok -En watches que permita agregar etiquetas a cada expresión
Por ejemplo si expresión es IX, etiqueta que diga "Dirección de carga"
Que se puedan activar etiquetas en cada watch independiente
* al agregar expresión: que meta etiqueta igual a expresión
* que sucede al editar expresión? no quiero que toque la etiqueta existente
Pero se distingue entre agregar y editar? Agregar seria cuando la existente está vacía
O directamente que el label muestre la que haya (si está vacía, meter igual a expresión)
* al mostrar, si label vacia: mostrar expresión. Esto es para facilitar updates de watches existentes en versiones anteriores,
sino el usuario lo veria en blanco

-view gosub stack como ventana en segundo plano y que se actualice continuamente


---------

-- Nuevo visor de Basic --

-Visor de basic que permita indicar dirección ram donde empezar: sirve para poder ver el bloque de basic
cargado desde el Cargador Azul por ejemplo
Quizá una ventana con una primera linea con dirección de inicio y otra info, y de la segunda linea hacia abajo que sea
el listado basic

ok *Sprite navigator por ejemplo usa una primera linea fija y la segunda para abajo variables

ok *Pero necesitaria ventana que trunque y justifique lineas, como una ventana de dialogo normal -> ejemplo en text adventure localidades
zxvision_generic_message_aux_justificar_lineas... para justificar
ok *y debug_view_basic_from_memory similar a como lo hace el file browser para mostrar vista basic con direccion inicio modificable

ok *misma ventana para basic normal y el modificable de direccion de inicio. con checkbox con algo como:
[x] Current basic / Start address
Si start address, que pregunte direccion inicio y también longitud en bytes

ok *que se pueda quedar en background. Que refresque al entrar y también estando en background si detecta cambios en programa
(quiza sacar un checksum cada 1 segundo de toda la longitud y ver si cambia)
ok *permitir betabasic: keywords son letras gráficas. opcion si mostrar keywords betabasic o no
ok *show address in view basic que aparezca también esa opción en la ventana (y quitarla del menu settings debug)
ok *funcion debug get basic limita el maximo de caracteres a MAX_TEXTO_GENERIC_MESSAGE
ok *Ver tokens adicionales de versiones superiores de betabasic
ok *poder buscar lineas
ok *permitir pgup, pgdn
ok *probar en linux meter poke continuo en direccion basic y ver si libera bien memoria de buffers
ok * Ver basic con interface 1 conectado
ok * que actualice current line continuamente
*poder buscar texto
* icono

*cada linea tiene doble salto de linea

-- Fin nuevo visor de Basic --

---------

-En view expanded desde tape input output etc que solo se pueda hacer View dentro, pero nada de move, delete, etc

-alguna manera que desde external audio source:
abra hexedit con expresión follow de ix
abra watches con watch DE, IX etc para la carga
abra vista basic
defina también tamaños de esas ventanas?



---------

--Nuevo algoritmo de lectura de audio y conversión a P/P81 de ZX81--
*si autodetectar amplitud por maximo de longitud de archivo resultante, no tiene sentido analisis de amplitudes
*analisis de amplitudes es complejo... con STOCKS vemos que el valor mas alto es
Amplitud 38 cantidad: 11926

Pero en cambio ese valor de 38 no da una lectura correcta del programa
(amplitud_media=39 Longitud nombre: 14 Longitud p81: 4248 Nombre: CONTROL STOCKS)
y realmente ocupa 6433 bytes y no 4248

Por tanto creo que lo mejor es que:
-Por defecto autodetectar. Que vayan saliendo valores finales en pantalla con longitudes y al final sea automaticamente el que decida
-Que el usuario pueda abortar la detección e indicar un valor preferido (o segun lo que vea en pantalla)
A igualdad de valores, ejemplo:

amplitud_media=14 Longitud nombre: 0 Longitud p81: 0 Nombre:
amplitud_media=15 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=16 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=17 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=18 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=19 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=20 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=21 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=22 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=23 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=24 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=25 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=26 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=27 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=28 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=29 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=30 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=31 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=32 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=33 Longitud nombre: 14 Longitud p81: 4249 Nombre: CONTROL STOCKS

Entre 15 y 32 son iguales, pero el 32 da resultado erroneo. Es mejor que el usuario escoja un valor entre medias (23 por ejemplo),
aunque el algoritmo escogera el 15 (que da resultado correcto), que es el primero del mas alto

-Este algoritmo está pensado para lecturas de cintas reales, con su señal imperfecta
Intentar leer una señal perfecta como la de unkatris (que ademas no tiene valores 0) provoca que no se  lean datos
En cambio mis archivos generados desde P a RWA, esos si que se leen bien

-Dos maneras (realmente 3) de llamar a la función de conversión de RWA a P/P81:
ok * desde file utils. convert RWA a P/P81. Automático sin preguntar amplitud
* por linea de comandos. convert RWA a P/P81. Automático sin preguntar amplitud
ok * desde storage->tape, nuevo submenu. con ventana en background, lanzando tarea como thread, viendo datos de autodetección
que diga también posibles errores (ejemplo "No sabemos que bit es cuando hay 6 pulsos")
marcado por defecto autodetección pero se puede especificar amplitud típica
*falta opcion de activar debug en ventana

*Luego también se podría integrar en visual real tape, la función que obtiene el nombre del programa y su longitud
*en menu_file_realtape_browser_show, con tecla V de view muestra los bloques de datos de un rwa, si es zx8081 o spectrum. creo que aqui
se llama tambien al usar visual real tape, esa info de bloques
*al insertar en standard tape un archivo smp/rwa, llama a snap_load_zx80_zx81_load_smp: ahi se deberia autodetectar,
y en algun sitio indicar si se usa el algoritmo viejo o el nuevo. OJO! que es comun a zx80 y zx81

*que ventana de conversión permita usar antiguo algoritmo?

*icono ventana


*entrada en changelog

*opcion para smartload directamente archivo generado en salida

*en View expanded, si se reusa archivo de salida, al ser una carpeta temporal, hay restos de las anteriores


*Carga turbo de stocks? Bajar pulsos a 2 y 4 creo

*Nota en algún sitio que esta conversión mejorada de raw a p/p81 requiere que se borren pulsos de ruido de antes de los datos,
se permite la zona de silencio de zx81 pero algún click que haya antes, mas alto de esas zonas de silencio, se deben borrar a mano
(ejemplo orquesta_zx81.rwa.gz incluye un click que hace que no cargue bien)

*f1 ayuda indicando como funciona y detallando el debug output

ok *poder buscar texto en debug output: por ejemplo Character para encontrar nombre

ok *Quizá si opción debug, sacar print por consola también. Así se supera el límite de ventana.  Indicarlo en mensaje de límite de líneas

ok *poder detener read enhanced desde thread externo
ok *read enhanced con funcion para obtener posicion actual: pos sample, pos output, ultimo byte, ultimo bit, conteo de pulsos de bit
ok *en current info ademas mostrar ultimos bytes leidos (un trozo de unos 10 o 20)
ok *que muestre samples leidos en ventana waveform, teniendo en cuenta que es el input convertido a rwa (si venia de un wav, mostrar el rwa de memoria). La función de utils de convert deberá dejar puntero a rwa y tamaño en alguna variable global
ok *conversion pausada, para asi poder ver los samples en ventana waveform a medida que se convierten. poderlo ralentizar o incluso congelar
hacerlo con un callback desde enhanced_zx81_read

ok *no poder cambiar input ni output mientras está en ejecución
*que se pueda escuchar la onda mientras se convierte
*poder editar la onda cuando haya un error - que se pare si hay un error. Requeriria otra ventana diferente de la waveform?
*que pasa si llega el pulso final y poco despues se acaba el archivo. lo finaliza bien?

ok * que la amplitud detectada la meta en setting de amplitude en la ventana

ok * Detectar frecuencia sampleo según ancho de un pulso (o de varios). Ajustar a conocidas: 15600, 11111, 44100 etc

*marcar inicio y final de pulso/bit/byte en waveform con linea vertical

*que diga nombre programa detectado, y no solo en las lineas debug

ok *en zoom hacer valores medios : si zoom 2, media de 2, si zoom 3 media de 3, etc

Señal highlight quizá que salga también con franja color inverso

ok Zoom señal. Ejemplo -2 zoom sería coordenada x *2? luego dar el valor medio de ese valor y el siguiente. Y así con 3,4 etc

ok Con zoom hay que ajustar que el byte leído sea siempre el de más a la derecha

ok -que pueda moverme por la señal, o que haga follow (lo que hace ahora). falta cambiar teclas movimiento

ok-poder escuchar señal: forzar detector silencio. pausa precisa
-mejorar texto de follow pos y cambio posicion

-Poder convertir turbo de cinta de stocks

--FIN Nuevo algoritmo de lectura de audio y conversión a P/P81 de ZX81--

-Nueva ventana para poder leer audio de cinta y generar archivo RWA