

-Opción por defecto no permitir "zoom x" diferente de "zoom y" al redimensionar ventana mediante ratón. Quedarse con valor inferior de zoom
ok *pendiente sdl1,sdl2,X11. acabar de probar bien

-SDL2 no deja cambiar a zoom 2 redimensionando con ratón

-sdl en debian 12 32 bits inicializa muy lento


---------------------

--Inicio lectura mando analógico, como un volante


Probar en diferentes sistemas:
*acabar de probarlo de nuevo en todos: SDL windows, SDL linux, linux nativo, mac.

*continental circus, ---steering-wheel-address b50ch, parece de 16 bits, pero no va bien. intentar que funcione


--Fin lectura mando analógico, como un volante

---------------------


ok -En watches que permita agregar etiquetas a cada expresión
Por ejemplo si expresión es IX, etiqueta que diga "Dirección de carga"
Que se puedan activar etiquetas en cada watch independiente
* al agregar expresión: que meta etiqueta igual a expresión
* que sucede al editar expresión? no quiero que toque la etiqueta existente
Pero se distingue entre agregar y editar? Agregar seria cuando la existente está vacía
O directamente que el label muestre la que haya (si está vacía, meter igual a expresión)
* al mostrar, si label vacia: mostrar expresión. Esto es para facilitar updates de watches existentes en versiones anteriores,
sino el usuario lo veria en blanco

-view gosub stack como ventana en segundo plano y que se actualice continuamente


---------

-- Nuevo visor de Basic --

-Visor de basic que permita indicar dirección ram donde empezar: sirve para poder ver el bloque de basic
cargado desde el Cargador Azul por ejemplo
Quizá una ventana con una primera linea con dirección de inicio y otra info, y de la segunda linea hacia abajo que sea
el listado basic

ok *Sprite navigator por ejemplo usa una primera linea fija y la segunda para abajo variables

ok *Pero necesitaria ventana que trunque y justifique lineas, como una ventana de dialogo normal -> ejemplo en text adventure localidades
zxvision_generic_message_aux_justificar_lineas... para justificar
ok *y debug_view_basic_from_memory similar a como lo hace el file browser para mostrar vista basic con direccion inicio modificable

ok *misma ventana para basic normal y el modificable de direccion de inicio. con checkbox con algo como:
[x] Current basic / Start address
Si start address, que pregunte direccion inicio y también longitud en bytes

ok *que se pueda quedar en background. Que refresque al entrar y también estando en background si detecta cambios en programa
(quiza sacar un checksum cada 1 segundo de toda la longitud y ver si cambia)
ok *permitir betabasic: keywords son letras gráficas. opcion si mostrar keywords betabasic o no
ok *show address in view basic que aparezca también esa opción en la ventana (y quitarla del menu settings debug)
ok *funcion debug get basic limita el maximo de caracteres a MAX_TEXTO_GENERIC_MESSAGE
ok *Ver tokens adicionales de versiones superiores de betabasic
ok *poder buscar lineas
ok *permitir pgup, pgdn
ok *probar en linux meter poke continuo en direccion basic y ver si libera bien memoria de buffers
ok * Ver basic con interface 1 conectado
ok * que actualice current line continuamente
*poder buscar texto
* icono

*cada linea tiene doble salto de linea

-- Fin nuevo visor de Basic --

---------

-En view expanded desde tape input output etc que solo se pueda hacer View dentro, pero nada de move, delete, etc

-alguna manera que desde external audio source:
abra hexedit con expresión follow de ix
abra watches con watch DE, IX etc para la carga
abra vista basic
defina también tamaños de esas ventanas?



---------

--Nuevo algoritmo de lectura de audio y conversión a P/P81 de ZX81--
*si autodetectar amplitud por maximo de longitud de archivo resultante, no tiene sentido analisis de amplitudes
*analisis de amplitudes es complejo... con STOCKS vemos que el valor mas alto es
Amplitud 38 cantidad: 11926

Pero en cambio ese valor de 38 no da una lectura correcta del programa
(amplitud_media=39 Longitud nombre: 14 Longitud p81: 4248 Nombre: CONTROL STOCKS)
y realmente ocupa 6433 bytes y no 4248

Por tanto creo que lo mejor es que:
-Por defecto autodetectar. Que vayan saliendo valores finales en pantalla con longitudes y al final sea automaticamente el que decida
-Que el usuario pueda abortar la detección e indicar un valor preferido (o segun lo que vea en pantalla)
A igualdad de valores, ejemplo:

amplitud_media=14 Longitud nombre: 0 Longitud p81: 0 Nombre:
amplitud_media=15 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=16 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=17 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=18 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=19 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=20 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=21 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=22 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=23 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=24 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=25 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=26 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=27 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=28 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=29 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=30 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=31 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=32 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=33 Longitud nombre: 14 Longitud p81: 4249 Nombre: CONTROL STOCKS

Entre 15 y 32 son iguales, pero el 32 da resultado erroneo. Es mejor que el usuario escoja un valor entre medias (23 por ejemplo),
aunque el algoritmo escogera el 15 (que da resultado correcto), que es el primero del mas alto

-Este algoritmo está pensado para lecturas de cintas reales, con su señal imperfecta
Intentar leer una señal perfecta como la de unkatris (que ademas no tiene valores 0) provoca que no se  lean datos
En cambio mis archivos generados desde P a RWA, esos si que se leen bien

-Dos maneras (realmente 3) de llamar a la función de conversión de RWA a P/P81:
ok * desde file utils. convert RWA a P/P81. Automático sin preguntar amplitud
* por linea de comandos. convert RWA a P/P81. Automático sin preguntar amplitud
ok * desde storage->tape, nuevo submenu. con ventana en background, lanzando tarea como thread, viendo datos de autodetección
que diga también posibles errores (ejemplo "No sabemos que bit es cuando hay 6 pulsos")
marcado por defecto autodetección pero se puede especificar amplitud típica
*falta opcion de activar debug en ventana

*Luego también se podría integrar en visual real tape, la función que obtiene el nombre del programa y su longitud
*en menu_file_realtape_browser_show, con tecla V de view muestra los bloques de datos de un rwa, si es zx8081 o spectrum. creo que aqui
se llama tambien al usar visual real tape, esa info de bloques
*al insertar en standard tape un archivo smp/rwa, llama a snap_load_zx80_zx81_load_smp: ahi se deberia autodetectar,
y en algun sitio indicar si se usa el algoritmo viejo o el nuevo. OJO! que es comun a zx80 y zx81

*que ventana de conversión permita usar antiguo algoritmo?


*entrada en changelog


*en View expanded, si se reusa archivo de salida, al ser una carpeta temporal, hay restos de las anteriores

*f1 ayuda indicando como funciona y detallando el debug output
*comentar en ayuda que esta conversión mejorada de raw a p/p81 requiere que se borren pulsos de ruido de antes de los datos,
se permite la zona de silencio de zx81 pero algún click que haya antes, mas alto de esas zonas de silencio, se deben borrar a mano
(ejemplo orquesta_zx81.rwa.gz incluye un click que hace que no cargue bien)


*poder editar la onda cuando haya un error - que se pare si hay un error (numero de pulsos desconocidos para valor de bit). Requeriria otra ventana diferente de la waveform?

*que pasa si llega el pulso final y poco despues se acaba el archivo. lo finaliza bien?


*usleep preciso para que funcione bien en windows?

*poder convertir audio de zx80?



*ajustar esto:
                        //Crestas de subida que sean 3 o 4 veces de mayor longitud que la cresta de bajada implica que hay un silencio antes de dicha onda
                        if (longitud_cresta_subida>longitud_cresta_bajada*3 && pulsos_leidos) {
realmente es *3? Bueno realmente es bastante mas que 3, ejemplo Rise length: 21 Fall length: 3


*Poder convertir turbo de cinta de stocks

*revisar pulsos que no son 4 u 8, realmente existen en el archivo de audio o es un error de la rutina?

ok *autodeteccion que escoja amplitud con archivo de salida mayor en tamaño, y en igualdad de condiciones,
que sea la amplitud que menos bits desconocidos obtenga (ejemplo de hacerlo detectado a 12 o manual a 15 en controlstocks_mas_recortado.rwa o a 20). OJO: 15 da resultado diferente que a 20, y en ambos no salta error de bits desconocidos!! Cual es el bueno? a 20 o a 15?
Habria que ver que bits son diferentes y por que
En teoria a 18 es perfecto, no salen bits desconocidos

ok ->en enh_zx81_lee_datos, meter otro parametro, puntero a variable que guarde bits desconocidos
Eso mostrarlo al final
Quedarse con, de los que sean mayor espacio generado, el que tenga menos bits desconocidos
Hacerlo para ventana y programa externo también
Y se podria tambien hacer (aunque igualmente avisando) que si es un numero de pulsos extraños, si es <=5, es un 0. y otra cosa, es un 1
Porque ahora mismo esta metiendo valor 0 para cualquier bit con pulsos desconocidos

ok -Quiza que con esos pulsos sospechosos se marquen en waveform. Pero para eso la rutina de conversión deberia
retornar una tabla con las posiciones de todos los sospechosos. Incluso podria haber una tecla para navegar entre esos pulsos sospechosos
Quiza pasar un puntero a esa tabla al llamar a convertir, indicando un maximo admitido: si hay muchos errores (+ de 100?) no tiene sentido revisarlos todos. Y que ademas diga conteo de pulsos que ha calculado la rutina en cada uno de esos fallos
Como siempre, NULL como parametro si no queremos eso

-waveform solo se puede visualizar cuando el thread esta activo
Quiza esto no es un problema pues siempre se puede lanzar y pausar para que se pueda examinar la señal
Por ejemplo si quiero ver todos los errores de pulsos, si lanzo y acaba el thread, no se vera
Habria que lanzar el thread y pausarlo antes de que acabe

-Load “nombre” en zx81 funciona buscando un archivo nombre.p81? O solo con .p?
No va , corregir rutina new_tap_load_detect_zx81

--FIN Nuevo algoritmo de lectura de audio y conversión a P/P81 de ZX81--



-Nueva ventana para poder leer audio de cinta y generar archivo RWA