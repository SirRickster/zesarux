

-Opción por defecto no permitir "zoom x" diferente de "zoom y" al redimensionar ventana mediante ratón. Quedarse con valor inferior de zoom
ok *pendiente sdl1,sdl2,X11. acabar de probar bien

-SDL2 no deja cambiar a zoom 2 redimensionando con ratón

-sdl en debian 12 32 bits inicializa muy lento


---------------------

--Inicio lectura mando analógico, como un volante


Probar en diferentes sistemas:
*acabar de probarlo de nuevo en todos: SDL windows, SDL linux, linux nativo, mac.

*continental circus, ---steering-wheel-address b50ch, parece de 16 bits, pero no va bien. intentar que funcione


--Fin lectura mando analógico, como un volante

---------------------


ok -En watches que permita agregar etiquetas a cada expresión
Por ejemplo si expresión es IX, etiqueta que diga "Dirección de carga"
Que se puedan activar etiquetas en cada watch independiente
* al agregar expresión: que meta etiqueta igual a expresión
* que sucede al editar expresión? no quiero que toque la etiqueta existente
Pero se distingue entre agregar y editar? Agregar seria cuando la existente está vacía
O directamente que el label muestre la que haya (si está vacía, meter igual a expresión)
* al mostrar, si label vacia: mostrar expresión. Esto es para facilitar updates de watches existentes en versiones anteriores,
sino el usuario lo veria en blanco

-view gosub stack como ventana en segundo plano y que se actualice continuamente


---------

-- Nuevo visor de Basic --

-Visor de basic que permita indicar dirección ram donde empezar: sirve para poder ver el bloque de basic
cargado desde el Cargador Azul por ejemplo
Quizá una ventana con una primera linea con dirección de inicio y otra info, y de la segunda linea hacia abajo que sea
el listado basic

ok *Sprite navigator por ejemplo usa una primera linea fija y la segunda para abajo variables

ok *Pero necesitaria ventana que trunque y justifique lineas, como una ventana de dialogo normal -> ejemplo en text adventure localidades
zxvision_generic_message_aux_justificar_lineas... para justificar
ok *y debug_view_basic_from_memory similar a como lo hace el file browser para mostrar vista basic con direccion inicio modificable

ok *misma ventana para basic normal y el modificable de direccion de inicio. con checkbox con algo como:
[x] Current basic / Start address
Si start address, que pregunte direccion inicio y también longitud en bytes

ok *que se pueda quedar en background. Que refresque al entrar y también estando en background si detecta cambios en programa
(quiza sacar un checksum cada 1 segundo de toda la longitud y ver si cambia)
ok *permitir betabasic: keywords son letras gráficas. opcion si mostrar keywords betabasic o no
ok *show address in view basic que aparezca también esa opción en la ventana (y quitarla del menu settings debug)
ok *funcion debug get basic limita el maximo de caracteres a MAX_TEXTO_GENERIC_MESSAGE
ok *Ver tokens adicionales de versiones superiores de betabasic
ok *poder buscar lineas
ok *permitir pgup, pgdn
ok *probar en linux meter poke continuo en direccion basic y ver si libera bien memoria de buffers
ok * Ver basic con interface 1 conectado
ok * que actualice current line continuamente
*poder buscar texto
* icono

*cada linea tiene doble salto de linea

-- Fin nuevo visor de Basic --

---------

-En view expanded desde tape input output etc que solo se pueda hacer View dentro, pero nada de move, delete, etc

-alguna manera que desde external audio source:
abra hexedit con expresión follow de ix
abra watches con watch DE, IX etc para la carga
abra vista basic
defina también tamaños de esas ventanas?



---------

--Nuevo algoritmo de lectura de audio y conversión a P/P81 de ZX81--
*si autodetectar amplitud por maximo de longitud de archivo resultante, no tiene sentido analisis de amplitudes
*analisis de amplitudes es complejo... con STOCKS vemos que el valor mas alto es
Amplitud 38 cantidad: 11926

Pero en cambio ese valor de 38 no da una lectura correcta del programa
(amplitud_media=39 Longitud nombre: 14 Longitud p81: 4248 Nombre: CONTROL STOCKS)
y realmente ocupa 6433 bytes y no 4248

Por tanto creo que lo mejor es que:
-Por defecto autodetectar. Que vayan saliendo valores finales en pantalla con longitudes y al final sea automaticamente el que decida
-Que el usuario pueda abortar la detección e indicar un valor preferido (o segun lo que vea en pantalla)
A igualdad de valores, ejemplo:

amplitud_media=14 Longitud nombre: 0 Longitud p81: 0 Nombre:
amplitud_media=15 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=16 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=17 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=18 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=19 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=20 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=21 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=22 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=23 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=24 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=25 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=26 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=27 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=28 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=29 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=30 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=31 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=32 Longitud nombre: 14 Longitud p81: 6433 Nombre: CONTROL STOCKS
amplitud_media=33 Longitud nombre: 14 Longitud p81: 4249 Nombre: CONTROL STOCKS

Entre 15 y 32 son iguales, pero el 32 da resultado erroneo. Es mejor que el usuario escoja un valor entre medias (23 por ejemplo),
aunque el algoritmo escogera el 15 (que da resultado correcto), que es el primero del mas alto

-Este algoritmo está pensado para lecturas de cintas reales, con su señal imperfecta
Intentar leer una señal perfecta como la de unkatris (que ademas no tiene valores 0) provoca que no se  lean datos
En cambio mis archivos generados desde P a RWA, esos si que se leen bien

-Dos maneras (realmente 3) de llamar a la función de conversión de RWA a P/P81:
ok * desde file utils. convert RWA a P/P81. Automático sin preguntar amplitud
* por linea de comandos. convert RWA a P/P81. Automático sin preguntar amplitud
ok * desde storage->tape, nuevo submenu. con ventana en background, lanzando tarea como thread, viendo datos de autodetección
que diga también posibles errores (ejemplo "No sabemos que bit es cuando hay 6 pulsos")
marcado por defecto autodetección pero se puede especificar amplitud típica
*falta opcion de activar debug en ventana

*Luego también se podría integrar en visual real tape, la función que obtiene el nombre del programa y su longitud
*en menu_file_realtape_browser_show, con tecla V de view muestra los bloques de datos de un rwa, si es zx8081 o spectrum. creo que aqui
se llama tambien al usar visual real tape, esa info de bloques
*al insertar en standard tape un archivo smp/rwa, llama a snap_load_zx80_zx81_load_smp: ahi se deberia autodetectar,
y en algun sitio indicar si se usa el algoritmo viejo o el nuevo. OJO! que es comun a zx80 y zx81

*que ventana de conversión permita usar antiguo algoritmo? DESCARTADO esto


*entrada en changelog


*en View expanded, si se reusa archivo de salida, al ser una carpeta temporal, hay restos de las anteriores

*f1 ayuda indicando como funciona y detallando el debug output
*comentar en ayuda que esta conversión mejorada de raw a p/p81 requiere que se borren pulsos de ruido de antes de los datos,
se permite la zona de silencio de zx81 pero algún click que haya antes, mas alto de esas zonas de silencio, se deben borrar a mano
(ejemplo orquesta_zx81.rwa.gz incluye un click que hace que no cargue bien)


*usleep preciso para que funcione bien en windows? Segun notas de hilow, algunos Linux tampoco
Mac parece hacerlo bien... o si?

*poder convertir audio de zx80?



ok -Puede leer .RAW sin problema? Mientras sea 8 bit unsigned debería funcionar

-un .RAW tambien identifica a una imagen de salida de hilow en formato crudo
-tambien un .raw es archivo de audio 44100hz, 8 bit, unsigned para entrada de sonido al convertir de cinta hilow a ddh
-y ahora tambien al capturar sonido, considero un .raw como archivo en crudo con frecuencia de sampleo 31200hz
En general, considerando audio, .raw seria formato en crudo, con cualquier samplerate. Y para todos los sitios considero 8 bit unsigned
Y para hilow de salida en crudo, es otra cosa, es formato hilow en crudo pero que no tiene que ver con el sonido


--FIN Nuevo algoritmo de lectura de audio y conversión a P/P81 de ZX81--




-Captura sonido a archivo de disco
*entrada en changelog
*opcion para archivo de salida en ventana de captura
ok *RWA (15600), RAW (44100?) y formato custom Hz (aunque captura son siempre 31200 hz, mas alla de eso se duplican bytes)
*si hay libreria audiofile, poder generar WAV de salida
*Permitir Signed al grabar raw?
*Resample a menos frecuencia tendría que hacer valor medio con los anteriores?


